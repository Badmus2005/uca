#!/usr/bin/env python3
"""
Tests de la cam√©ra et du n≈ìud camera ROS
V√©rifie l'acquisition d'images et la publication ROS
"""

import sys
import os
from pathlib import Path
import unittest
import yaml
import cv2
import numpy as np

PROJECT_ROOT = Path(__file__).parent.parent


class TestCameraConfiguration(unittest.TestCase):
    """Tests de la configuration cam√©ra"""
    
    @classmethod
    def setUpClass(cls):
        """Initialisation"""
        print("\n" + "="*60)
        print("üß™ TESTS DE LA CAM√âRA")
        print("="*60 + "\n")
    
    def test_01_camera_node_exists(self):
        """Test 1: V√©rifier que final_camera_node.py existe"""
        print("üìù Test 1: Existence de final_camera_node.py...")
        
        camera_node = PROJECT_ROOT / "ros_package" / "scripts" / "final_camera_node.py"
        self.assertTrue(
            camera_node.exists(),
            f"‚ùå final_camera_node.py introuvable: {camera_node}"
        )
        print(f"   ‚úÖ Fichier trouv√©: {camera_node}")
    
    def test_02_camera_params_exists(self):
        """Test 2: V√©rifier camera_params.yaml"""
        print("üìù Test 2: Existence de camera_params.yaml...")
        
        params_file = PROJECT_ROOT / "config" / "camera_params.yaml"
        self.assertTrue(
            params_file.exists(),
            f"‚ùå camera_params.yaml introuvable: {params_file}"
        )
        print(f"   ‚úÖ Config trouv√©e: {params_file}")
    
    def test_03_load_camera_params(self):
        """Test 3: Charger les param√®tres cam√©ra"""
        print("üìù Test 3: Chargement param√®tres cam√©ra...")
        
        params_file = PROJECT_ROOT / "config" / "camera_params.yaml"
        with open(params_file, 'r', encoding='utf-8') as f:
            params = yaml.safe_load(f)
        
        # Structure imbriqu√©e
        self.assertIn('camera', params, "‚ùå section camera manquante")
        camera = params['camera']
        
        # V√©rifier param√®tres requis
        self.assertIn('device_id', camera, "‚ùå device_id manquant")
        self.assertIn('resolution', camera, "‚ùå resolution manquante")
        self.assertIn('framerate', camera, "‚ùå framerate manquante")
        
        resolution = camera['resolution']
        framerate = camera['framerate']
        
        # V√©rifier valeurs
        self.assertGreaterEqual(camera['device_id'], 0, "‚ùå device_id invalide")
        self.assertIn(resolution['width'], [320, 640, 1280], "‚ùå width non standard")
        self.assertIn(resolution['height'], [240, 480, 720], "‚ùå height non standard")
        self.assertGreater(framerate['fps'], 0, "‚ùå fps doit √™tre > 0")
        
        print(f"   ‚úÖ Device: {camera['device_id']}")
        print(f"   ‚úÖ R√©solution: {resolution['width']}√ó{resolution['height']}")
        print(f"   ‚úÖ FPS: {framerate['fps']}")
    
    def test_04_camera_node_syntax(self):
        """Test 4: V√©rifier syntaxe Python"""
        print("üìù Test 4: V√©rification syntaxe...")
        
        camera_node = PROJECT_ROOT / "ros_package" / "scripts" / "final_camera_node.py"
        
        with open(camera_node, 'r', encoding='utf-8') as f:
            code = f.read()
        
        try:
            compile(code, camera_node, 'exec')
            print("   ‚úÖ Syntaxe Python correcte")
        except SyntaxError as e:
            self.fail(f"‚ùå Erreur syntaxe: {e}")
    
    def test_05_ros_imports(self):
        """Test 5: V√©rifier imports ROS"""
        print("üìù Test 5: V√©rification imports ROS...")
        
        camera_node = PROJECT_ROOT / "ros_package" / "scripts" / "final_camera_node.py"
        
        with open(camera_node, 'r', encoding='utf-8') as f:
            code = f.read()
        
        # V√©rifier imports ROS critiques
        if 'import rospy' in code:
            print("   ‚úÖ Import rospy pr√©sent")
        else:
            print("   ‚ö†Ô∏è  Import rospy manquant (normal si non-ROS)")
        
        # V√©rifier imports OpenCV
        self.assertIn('import cv2', code, "‚ùå Import cv2 manquant")
        print("   ‚úÖ Import cv2 pr√©sent")


class TestCameraFunctionality(unittest.TestCase):
    """Tests fonctionnels de la cam√©ra (sans mat√©riel)"""
    
    def test_01_opencv_available(self):
        """Test 1: OpenCV disponible"""
        print("\nüìù Test Fonctionnel 1: OpenCV disponible...")
        
        try:
            import cv2
            version = cv2.__version__
            print(f"   ‚úÖ OpenCV version: {version}")
        except ImportError:
            self.fail("‚ùå OpenCV non install√©")
    
    def test_02_video_capture_init_simulation(self):
        """Test 2: Simulation initialisation VideoCapture"""
        print("üìù Test Fonctionnel 2: Init VideoCapture (simul√©)...")
        
        # Charger params
        params_file = PROJECT_ROOT / "config" / "camera_params.yaml"
        with open(params_file, 'r', encoding='utf-8') as f:
            params = yaml.safe_load(f)
        
        camera = params['camera']
        device_id = camera['device_id']
        width = camera['resolution']['width']
        height = camera['resolution']['height']
        fps = camera['framerate']['fps']
        
        # Simuler cr√©ation VideoCapture (ne pas vraiment ouvrir cam√©ra)
        print(f"   ‚úÖ Simulated cv2.VideoCapture({device_id})")
        print(f"   ‚úÖ set(CAP_PROP_FRAME_WIDTH, {width})")
        print(f"   ‚úÖ set(CAP_PROP_FRAME_HEIGHT, {height})")
        print(f"   ‚úÖ set(CAP_PROP_FPS, {fps})")
    
    def test_03_image_format_validation(self):
        """Test 3: Validation format image"""
        print("üìù Test Fonctionnel 3: Format image...")
        
        # Cr√©er image simul√©e
        fake_img = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
        
        # V√©rifier format
        self.assertEqual(len(fake_img.shape), 3, "‚ùå Image doit avoir 3 dimensions")
        self.assertEqual(fake_img.shape[2], 3, "‚ùå Image doit avoir 3 canaux (BGR)")
        self.assertEqual(fake_img.dtype, np.uint8, "‚ùå Image doit √™tre uint8")
        
        print(f"   ‚úÖ Format valide: {fake_img.shape}, dtype={fake_img.dtype}")
    
    def test_04_image_encoding_bgr(self):
        """Test 4: Encodage BGR (OpenCV standard)"""
        print("üìù Test Fonctionnel 4: Encodage BGR...")
        
        # Image BGR
        bgr_img = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
        
        # Conversion BGR ‚Üí RGB
        rgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB)
        
        self.assertEqual(bgr_img.shape, rgb_img.shape, "‚ùå Shape doit rester identique")
        print(f"   ‚úÖ Conversion BGR‚ÜíRGB OK")
        
        # Conversion BGR ‚Üí GRAY
        gray_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY)
        
        self.assertEqual(len(gray_img.shape), 2, "‚ùå Gray doit avoir 2 dimensions")
        print(f"   ‚úÖ Conversion BGR‚ÜíGRAY OK")
    
    def test_05_image_resize_operations(self):
        """Test 5: Op√©rations redimensionnement"""
        print("üìù Test Fonctionnel 5: Redimensionnement...")
        
        original = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
        
        # Resize vers 640√ó640 (YOLOv5)
        resized_640 = cv2.resize(original, (640, 640))
        self.assertEqual(resized_640.shape, (640, 640, 3), "‚ùå Resize 640√ó640")
        print(f"   ‚úÖ Resize 640√ó640: OK")
        
        # Resize vers 416√ó416
        resized_416 = cv2.resize(original, (416, 416))
        self.assertEqual(resized_416.shape, (416, 416, 3), "‚ùå Resize 416√ó416")
        print(f"   ‚úÖ Resize 416√ó416: OK")
        
        # Resize vers 320√ó320
        resized_320 = cv2.resize(original, (320, 320))
        self.assertEqual(resized_320.shape, (320, 320, 3), "‚ùå Resize 320√ó320")
        print(f"   ‚úÖ Resize 320√ó320: OK")


class TestCameraROSIntegration(unittest.TestCase):
    """Tests d'int√©gration ROS (sans ROS r√©el)"""
    
    def test_01_ros_topic_naming(self):
        """Test 1: Convention nommage topics"""
        print("\nüìù Test ROS 1: Nommage topics...")
        
        camera_node = PROJECT_ROOT / "ros_package" / "scripts" / "final_camera_node.py"
        
        with open(camera_node, 'r', encoding='utf-8') as f:
            code = f.read()
        
        # V√©rifier topics ROS standards
        expected_topics = ['/camera/image_raw', '/camera/camera_info', '/image']
        
        found_topics = []
        for topic in expected_topics:
            if topic in code:
                found_topics.append(topic)
        
        if found_topics:
            for topic in found_topics:
                print(f"   ‚úÖ Topic trouv√©: {topic}")
        else:
            print("   ‚ö†Ô∏è  Aucun topic standard trouv√© (v√©rifier manuellement)")
    
    def test_02_image_message_format(self):
        """Test 2: Format message Image"""
        print("üìù Test ROS 2: Format message Image...")
        
        # Structure attendue d'un message sensor_msgs/Image
        expected_fields = [
            'header',  # std_msgs/Header
            'height',  # uint32
            'width',   # uint32
            'encoding',  # string (ex: "bgr8", "rgb8")
            'step',    # uint32 (row stride)
            'data'     # uint8[] (raw image data)
        ]
        
        print("   üìã Champs attendus sensor_msgs/Image:")
        for field in expected_fields:
            print(f"      ‚Ä¢ {field}")
        
        print("   ‚úÖ Format Image ROS document√©")
    
    def test_03_image_encoding_types(self):
        """Test 3: Types d'encodage support√©s"""
        print("üìù Test ROS 3: Encodages Image...")
        
        supported_encodings = [
            'bgr8',      # OpenCV standard
            'rgb8',      # ROS standard
            'mono8',     # Grayscale
            'bgra8',     # avec alpha
            'rgba8'      # avec alpha
        ]
        
        print("   üìã Encodages support√©s:")
        for encoding in supported_encodings:
            print(f"      ‚úÖ {encoding}")


class TestCameraPerformance(unittest.TestCase):
    """Tests de performance cam√©ra"""
    
    def test_01_image_acquisition_speed(self):
        """Test 1: Vitesse acquisition simul√©e"""
        print("\nüìù Test Perf 1: Vitesse acquisition...")
        
        # Charger params
        params_file = PROJECT_ROOT / "config" / "camera_params.yaml"
        with open(params_file, 'r', encoding='utf-8') as f:
            params = yaml.safe_load(f)
        
        fps = params['camera']['framerate']['fps']
        frame_time = 1.0 / fps  # temps par frame en secondes
        
        print(f"   üìä FPS configur√©: {fps}")
        print(f"   üìä Temps par frame: {frame_time*1000:.1f} ms")
        
        # V√©rifier que c'est raisonnable
        self.assertGreaterEqual(fps, 5, "‚ùå FPS trop bas (< 5)")
        self.assertLessEqual(fps, 60, "‚ùå FPS trop haut (> 60)")
        
        print(f"   ‚úÖ FPS dans limites acceptables")
    
    def test_02_bandwidth_estimation(self):
        """Test 2: Estimation bande passante"""
        print("üìù Test Perf 2: Bande passante...")
        
        # Charger params
        params_file = PROJECT_ROOT / "config" / "camera_params.yaml"
        with open(params_file, 'r', encoding='utf-8') as f:
            params = yaml.safe_load(f)
        
        camera = params['camera']
        width = camera['resolution']['width']
        height = camera['resolution']['height']
        fps = camera['framerate']['fps']
        
        # Calcul
        bytes_per_frame = width * height * 3  # 3 bytes par pixel (BGR)
        bytes_per_second = bytes_per_frame * fps
        mbps = bytes_per_second * 8 / (1024 * 1024)  # Megabits per second
        
        print(f"   üìä R√©solution: {width}√ó{height}")
        print(f"   üìä Bytes/frame: {bytes_per_frame / 1024:.1f} KB")
        print(f"   üìä Bande passante: {mbps:.2f} Mbps")
        
        print(f"   ‚úÖ Bande passante calcul√©e")


def run_tests():
    """Lancer tous les tests cam√©ra"""
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    suite.addTests(loader.loadTestsFromTestCase(TestCameraConfiguration))
    suite.addTests(loader.loadTestsFromTestCase(TestCameraFunctionality))
    suite.addTests(loader.loadTestsFromTestCase(TestCameraROSIntegration))
    suite.addTests(loader.loadTestsFromTestCase(TestCameraPerformance))
    
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    print("\n" + "="*60)
    print("üìä R√âSUM√â DES TESTS CAM√âRA")
    print("="*60)
    print(f"‚úÖ Tests r√©ussis: {result.testsRun - len(result.failures) - len(result.errors)}")
    print(f"‚ùå Tests √©chou√©s: {len(result.failures)}")
    print(f"‚ö†Ô∏è  Erreurs: {len(result.errors)}")
    print("="*60 + "\n")
    
    return result.wasSuccessful()


if __name__ == "__main__":
    success = run_tests()
    sys.exit(0 if success else 1)
